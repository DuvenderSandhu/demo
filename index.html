<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OCR Document Maker</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-size: 18px;
        }
        #container {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 800px;
            width: 100%;
        }
        h1 {
            font-size: 28px;
        }
        button {
            font-size: 20px;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
        }
        #fileInput {
            display: none;
        }
        #preview {
            margin: 20px 0;
            max-height: 300px;
            overflow: auto;
        }
        #preview img {
            max-width: 100%;
        }
        #textArea {
            width: 100%;
            height: 300px;
            font-size: 18px;
            padding: 10px;
            box-sizing: border-box;
            direction: ltr; /* Adjust if needed for Hindi */
        }
        #progress {
            font-size: 20px;
            color: green;
            margin: 10px 0;
        }
        label {
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>OCR Document Maker</h1>
        <button id="uploadBtn">Upload Image or PDF</button>
        <input type="file" id="fileInput" accept="image/*,application/pdf" multiple>
        <div id="preview"></div>
        <label><input type="checkbox" id="thresholdChk"> Apply Thresholding (Optional)</label><br>
        <label><input type="checkbox" id="psmChk" checked> Use LSTM OCR (Better for Handwriting)</label><br>
        <button id="ocrBtn">Start OCR</button>
        <textarea id="textArea" placeholder="Extracted text will appear here..."></textarea>
        <select id="langSelect">
            <option value="en-US">English</option>
            <option value="hi-IN">Hindi</option>
        </select>
        <button id="voiceBtn">Voice Typing</button>
        <button id="convertBtn">Convert Kruti Dev → Unicode</button>
        <button id="exportPdfBtn">Export as PDF</button>
        <button id="exportWordBtn">Export as Word (.doc)</button>
        <div id="progress"></div>
    </div>

    <!-- CDN Scripts -->
    <script src="https://unpkg.com/tesseract.js@v5.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs"></script>

    <script>
        // Ensure pdf.js worker is set after the script loads
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof window.pdfjsLib !== 'undefined') {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.mjs';
            } else {
                console.error('pdf.js failed to load.');
                document.getElementById('progress').textContent = 'Error: pdf.js not loaded. PDF support disabled.';
            }
        });

        // Element references
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const preview = document.getElementById('preview');
        const ocrBtn = document.getElementById('ocrBtn');
        const textArea = document.getElementById('textArea');
        const convertBtn = document.getElementById('convertBtn');
        const exportPdfBtn = document.getElementById('exportPdfBtn');
        const exportWordBtn = document.getElementById('exportWordBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const langSelect = document.getElementById('langSelect');
        const thresholdChk = document.getElementById('thresholdChk');
        const psmChk = document.getElementById('psmChk');
        const progress = document.getElementById('progress');

        // Canvas for image processing
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        let currentCanvases = []; // Array to hold canvases for multi-page

        // Upload button triggers file input
        uploadBtn.onclick = () => fileInput.click();

        // Handle file upload (support multiple for multi-page PDFs)
        fileInput.onchange = async (e) => {
            const files = e.target.files;
            if (!files || files.length === 0) {
                progress.textContent = 'No file selected.';
                return;
            }
            preview.innerHTML = '';
            currentCanvases = [];
            progress.textContent = 'Loading file(s)...';
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const url = URL.createObjectURL(file);
                if (file.type === 'application/pdf') {
                    await loadPdf(url);
                } else if (file.type.startsWith('image/')) {
                    await loadImage(url);
                } else {
                    progress.textContent += ` Unsupported file type for ${file.name}.`;
                }
            }
            progress.textContent = 'Files loaded.';
        };

        // Load image to canvas and preview
        function loadImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    currentCanvases.push(canvas);
                    const previewImg = new Image();
                    previewImg.src = url;
                    preview.appendChild(previewImg);
                    resolve();
                };
                img.onerror = () => {
                    progress.textContent += ' Error loading image.';
                    resolve();
                };
                img.src = url;
            });
        }

        // Load PDF to canvases (multi-page support) and preview
        async function loadPdf(url) {
            if (typeof window.pdfjsLib === 'undefined') {
                progress.textContent = 'PDF support not available.';
                return;
            }
            const loadingTask = window.pdfjsLib.getDocument(url);
            const pdf = await loadingTask.promise;
            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const scale = 2.0; // Higher scale for better OCR accuracy
                const viewport = page.getViewport({ scale });
                canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                ctx = canvas.getContext('2d');
                const renderContext = { canvasContext: ctx, viewport };
                await page.render(renderContext).promise;
                currentCanvases.push(canvas);
                const previewImg = new Image();
                previewImg.src = canvas.toDataURL();
                preview.appendChild(previewImg);
                preview.innerHTML += `<p>Page ${pageNum}</p>`;
            }
        }

        // OCR processing (multi-page support)
        ocrBtn.onclick = async () => {
            if (currentCanvases.length === 0) {
                alert('Please upload an image or PDF first.');
                return;
            }
            let fullText = '';
            progress.textContent = 'Initializing OCR...';
            const worker = await Tesseract.createWorker({
                logger: m => progress.textContent = `${m.status}: ${Math.round(m.progress * 100)}%`,
            });
            await worker.load();
            await worker.loadLanguage('eng+hin');
            await worker.initialize('eng+hin');
            if (psmChk.checked) {
                await worker.setParameters({ tessedit_pageseg_mode: '1' }); // PSM 1: Automatic page segmentation with OSD (better for handwriting)
            }
            for (let i = 0; i < currentCanvases.length; i++) {
                progress.textContent = `Preprocessing page ${i+1}...`;
                preprocessCanvas(currentCanvases[i]);
                progress.textContent = `Recognizing page ${i+1}...`;
                const { data: { text } } = await worker.recognize(currentCanvases[i]);
                fullText += text + '\n\n--- Page ' + (i+1) + ' ---\n\n';
            }
            textArea.value = fullText;
            await worker.terminate();
            progress.textContent = 'OCR completed.';
        };

        // Image preprocessing per canvas
        function preprocessCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            // Grayscale
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                let gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);

            // Increase contrast
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;
            const factor = 2.0; // Higher contrast for handwriting
            for (let i = 0; i < data.length; i += 4) {
                for (let j = 0; j < 3; j++) {
                    let val = ((data[i + j] / 255 - 0.5) * factor + 0.5) * 255;
                    data[i + j] = Math.min(255, Math.max(0, val));
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // Optional thresholding
            if (thresholdChk.checked) {
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    let gray = data[i];
                    let val = gray > 128 ? 255 : 0;
                    data[i] = data[i + 1] = data[i + 2] = val;
                }
                ctx.putImageData(imageData, 0, 0);
            }
        }

        // Kruti Dev to Unicode conversion (unchanged)
        convertBtn.onclick = () => {
            textArea.value = krutiToUnicode(textArea.value);
            progress.textContent = 'Converted to Unicode.';
        };

        function krutiToUnicode(text) {
            text += ' ';
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])([\u0901])/g, "$2$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])([\u0902])/g, "$2$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])(ं)/g, "ं$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])(ॅ)/g, "ॅ$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])(ॉ)/g, "ॉ$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ा/g, "ा$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ि/g, "ि$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ी/g, "ी$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ु/g, "ु$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ू/g, "ू$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ृ/g, "ृ$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])े/g, "े$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ै/g, "ै$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ो/g, "ो$1");
            text = text.replace(/([कखगघचछजझञटठडढणतथदधनपफबभमयरलवशषसहक़ख़ग़ज़ड़ढ़फ़य़ळ])ौ/g, "ौ$1");

            text = text.replace(/É/g, 'क़');
            text = text.replace(/ç/g, 'फ़');
            text = text.replace(/ƒ/g, 'ज़');
            text = text.replace(/˜/g, 'ख़');
            text = text.replace(/×/g, 'ग़');
            text = text.replace(/Ä/g, 'ढ़');
            text = text.replace(/Æ/g, 'झ़');
            text = text.replace(/È/g, 'क़');
            text = text.replace(//g, 'ड़');
            text = text.replace(/Ñ/g, 'ळ');
            text = text.replace(/Ê/g, 'क्ष');
            text = text.replace(/ë/g, 'त्र');
            text = text.replace(//g, 'ज्ञ');
            text = text.replace(/„/g, 'श्र');
            text = text.replace(/A/g, 'अ');
            text = text.replace(/B/g, 'आ');
            text = text.replace(/C/g, 'इ');
            text = text.replace(/D/g, 'ई');
            text = text.replace(/E/g, 'उ');
            text = text.replace(/F/g, 'ऊ');
            text = text.replace(/G/g, 'ऋ');
            text = text.replace(/H/g, 'ऌ');
            text = text.replace(/I/g, 'ऍ');
            text = text.replace(/J/g, 'ऐ');
            text = text.replace(/K/g, 'ऑ');
            text = text.replace(/L/g, 'ओ');
            text = text.replace(/M/g, 'औ');
            text = text.replace(/N/g, 'अं');
            text = text.replace(/O/g, 'अः');
            text = text.replace(/0/g, '०');
            text = text.replace(/1/g, '१');
            text = text.replace(/2/g, '२');
            text = text.replace(/3/g, '३');
            text = text.replace(/4/g, '४');
            text = text.replace(/5/g, '५');
            text = text.replace(/6/g, '६');
            text = text.replace(/7/g, '७');
            text = text.replace(/8/g, '८');
            text = text.replace(/9/g, '९');

            text = text.trim();
            return text;
        }

        // Export as PDF (multi-page, preserve layout by adding images)
        exportPdfBtn.onclick = () => {
            if (!textArea.value && currentCanvases.length === 0) {
                alert('No content to export.');
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const imgWidth = 180;
            const pageHeight = doc.internal.pageSize.height - 20;
            let yPos = 10;
            const lines = textArea.value.split('\n');
            let pageIndex = 0;

            // Add OCR text
            for (let line of lines) {
                if (yPos > pageHeight) {
                    doc.addPage();
                    yPos = 10;
                }
                doc.text(line, 10, yPos);
                yPos += 7; // Line height
            }

            // Add original images to preserve design (append pages)
            for (let canvas of currentCanvases) {
                if (pageIndex > 0 || textArea.value) doc.addPage();
                const imgData = canvas.toDataURL('image/png');
                doc.addImage(imgData, 'PNG', 10, 10, imgWidth, (canvas.height / canvas.width) * imgWidth);
                pageIndex++;
            }
            doc.save('document.pdf');
            progress.textContent = 'PDF exported with original design.';
        };

        // Export as Word (.doc) - Basic text, note: .doc doesn't support images easily, so text only
        exportWordBtn.onclick = () => {
            if (!textArea.value) {
                alert('No text to export.');
                return;
            }
            const blob = new Blob([textArea.value], { type: 'application/msword' });
            saveAs(blob, 'document.doc');
            progress.textContent = 'Word document exported (text only; for design, use PDF).';
        };

        // Voice typing (unchanged)
        let recognition = null;
        voiceBtn.onclick = () => {
            if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) {
                alert('Web Speech API not supported in this browser.');
                return;
            }
            if (recognition) {
                recognition.stop();
                recognition = null;
                voiceBtn.textContent = 'Voice Typing';
                progress.textContent = 'Voice typing stopped.';
                return;
            }
            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.lang = langSelect.value;
            recognition.interimResults = true;
            recognition.onresult = (event) => {
                let transcript = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                }
                insertTextAtCursor(transcript);
            };
            recognition.onerror = (event) => {
                progress.textContent = 'Voice error: ' + event.error;
            };
            recognition.onend = () => {
                recognition = null;
                voiceBtn.textContent = 'Voice Typing';
                progress.textContent = 'Voice typing stopped.';
            };
            recognition.start();
            voiceBtn.textContent = 'Stop Voice Typing';
            progress.textContent = 'Voice typing started...';
        };

        function insertTextAtCursor(text) {
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            textArea.value = textArea.value.substring(0, start) + text + textArea.value.substring(end);
            textArea.selectionStart = textArea.selectionEnd = start + text.length;
            textArea.focus();
        }
    </script>
</body>
</html>
